#ifndef REFLECT_METADDATA_HPP
#define REFLECT_METADDATA_HPP

#include "../meta_utils/meta_utils.hpp"
#include "../reflect_information/reflect_information.hpp"

namespace reflect {

namespace utils {

namespace detail {

template <class... Args> struct get_method_args_helper_impl {constexpr static auto value {::boost::hana::tuple_t<Args...>};};

template <class... Args> struct get_method_args_helper_impl<::boost::hana::tuple<Args...>> {constexpr static auto value {::boost::hana::tuple_t<Args...>};};

}

template <class T>
using MetaClass = info::MetaClass<typename ::std::decay_t<typename T::MetaInfo_type>>; /**< Helper type template to specify Metadata class */

/**
 * @brief Returns class name
 * @return ct-string (boost::hana::string)
 */
template <class T>
constexpr decltype (auto) get_class_name() {
    if constexpr (!info::is_reflected_v<::std::decay_t<T>>) return ::boost::hana::nothing;
    return info::MetaClass<typename ::std::decay_t<typename T::MetaInfo_type> >::class_name;
}

/**
 * @brief Returns amount of elements generated by the generator
 * @return boost::hana::size_t
 */
template <class T, class Generator = info::DefaultIndexGenerator>
constexpr decltype (auto) get_count() {
    if constexpr (!info::is_reflected_v<::std::decay_t<T>>) return ::boost::hana::nothing;
    if constexpr (!info::is_generator_v<::std::decay_t<Generator>>) return ::boost::hana::nothing;
    //Forcing unevaluated context to not interact with data(only with types)
    return boost::hana::size_c<decltype(::boost::hana::size(metautils::copy_tuple_sequence(MetaClass<T>::metadata,Generator::template generate<decltype(MetaClass<T>::metadata)>())))::value>;
}

/**
 * @brief Get name of element
 * @param index - index of number(boost::hana::size_t)
 * @return ct-string (boost::hana::string)
 */
template <class T, class Generator = info::DefaultIndexGenerator, class I>
constexpr decltype (auto) get_name (I&& index) {
    if constexpr (!info::is_reflected_v<::std::decay_t<T>>) return ::boost::hana::nothing;
    if constexpr (!info::is_generator_v<::std::decay_t<Generator>>) return ::boost::hana::nothing;
    if constexpr (decltype(::boost::hana::size(metautils::copy_tuple_sequence(MetaClass<T>::names,Generator::template generate<decltype(MetaClass<T>::metadata)>())))::value
                  <= ::std::decay_t<I>::value) return ::boost::hana::nothing;
    return ::boost::hana::at(metautils::copy_tuple_sequence(MetaClass<T>::names,Generator::template generate<decltype(MetaClass<T>::metadata)>()),index);
}

/**
 * @brief Find element index by name
 * @param str - ct-string (boost::hana::string)
 * @return boost::hana::size_t
 */
template <class T, class Generator = info::DefaultIndexGenerator, class String>
constexpr decltype (auto) find_name(String&& str) {
    if constexpr (!info::is_reflected_v<::std::decay_t<T>>) return ::boost::hana::nothing;
    if constexpr (!info::is_generator_v<::std::decay_t<Generator>>) return ::boost::hana::nothing;
    return metautils::find_value_types(str,metautils::copy_tuple_sequence(MetaClass<T>::names,Generator::template generate<decltype(MetaClass<T>::metadata)>()));
}

/**
 * @brief Return args types of method
 * @param index - method index
 * @return boost::hana::tuple_t<Types...>
 */
template<class T, class Generator = info::DefaultIndexGenerator, class I>
constexpr decltype (auto) get_method_args(I&& index) {
    return detail::get_method_args_helper_impl<typename ::std::decay_t<decltype(::boost::hana::at(metautils::copy_tuple_sequence(MetaClass<T>::metadata,Generator::template generate<decltype(MetaClass<T>::metadata)>())
                                                                                                ,index))>::arg_types>::value;
}

/**
 * @brief Returns result type of method
 * @param index - method index
 * @return boost::hana::type_t<...>
 */
template<class T, class Generator = info::DefaultIndexGenerator, class I>
constexpr decltype (auto) get_method_result_type(I&& index) {
    return ::boost::hana::type_c<typename ::std::decay_t<decltype(::boost::hana::at(metautils::copy_tuple_sequence(MetaClass<T>::metadata,Generator::template generate<decltype(MetaClass<T>::metadata)>())
                                                            ,index))>::return_type>;
}

/**
 * @brief Returns Jth argument type of method
 * @param index1 - method index
 * @param index2 - argument index
 *
 */
template<class T, class Generator = info::DefaultIndexGenerator, class I, class J>
constexpr decltype (auto) get_method_arg(I&& index1, J&& index2) {
    if constexpr (decltype (::boost::hana::size(get_method_args<T,Generator>(::std::forward<I>(index1))))::value > std::decay_t<J>::value)
            return ::boost::hana::at(get_method_args<T,Generator>(::std::forward<I>(index1)),index2);
    else return ::boost::hana::type_c<std::decay_t<decltype(::boost::hana::nothing)>>;
}

constexpr decltype (auto) check_invoke() {

}

}

}

#endif // REFLECT_METADDATA_HPP
